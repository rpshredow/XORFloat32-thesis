// megafunction wizard: %ALTFP_INV%
// GENERATION: STANDARD
// VERSION: WM1.0
// MODULE: ALTFP_INV 

// ============================================================
// File Name: inverse.v
// Megafunction Name(s):
// 			ALTFP_INV
//
// Simulation Library Files(s):
// 			lpm
// ============================================================
// ************************************************************
// THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!
//
// 18.1.0 Build 625 09/12/2018 SJ Lite Edition
// ************************************************************


//Copyright (C) 2018  Intel Corporation. All rights reserved.
//Your use of Intel Corporation's design tools, logic functions 
//and other software and tools, and its AMPP partner logic 
//functions, and any output files from any of the foregoing 
//(including device programming or simulation files), and any 
//associated documentation or information are expressly subject 
//to the terms and conditions of the Intel Program License 
//Subscription Agreement, the Intel Quartus Prime License Agreement,
//the Intel FPGA IP License Agreement, or other applicable license
//agreement, including, without limitation, that your use is for
//the sole purpose of programming logic devices manufactured by
//Intel and sold by Intel or its authorized distributors.  Please
//refer to the applicable agreement for further details.


//altfp_inv CBX_AUTO_BLACKBOX="ALL" DEVICE_FAMILY="Cyclone V" PIPELINE=20 ROUNDING="TO_NEAREST" WIDTH_EXP=8 WIDTH_MAN=23 clock data result
//VERSION_BEGIN 18.1 cbx_altfp_inv 2018:09:12:13:04:09:SJ cbx_cycloneii 2018:09:12:13:04:09:SJ cbx_lpm_add_sub 2018:09:12:13:04:09:SJ cbx_lpm_compare 2018:09:12:13:04:09:SJ cbx_lpm_mult 2018:09:12:13:04:09:SJ cbx_lpm_mux 2018:09:12:13:04:09:SJ cbx_mgl 2018:09:12:14:15:07:SJ cbx_nadder 2018:09:12:13:04:09:SJ cbx_padd 2018:09:12:13:04:09:SJ cbx_stratix 2018:09:12:13:04:09:SJ cbx_stratixii 2018:09:12:13:04:09:SJ cbx_util_mgl 2018:09:12:13:04:09:SJ  VERSION_END
// synthesis VERILOG_INPUT_VERSION VERILOG_2001
// altera message_off 10463



//altfp_inv_and_or CBX_AUTO_BLACKBOX="ALL" DEVICE_FAMILY="Cyclone V" LUT_INPUT_COUNT=6 OPERATION="OR" PIPELINE=3 WIDTH=23 aclr clken clock data result
//VERSION_BEGIN 18.1 cbx_altfp_inv 2018:09:12:13:04:09:SJ cbx_cycloneii 2018:09:12:13:04:09:SJ cbx_lpm_add_sub 2018:09:12:13:04:09:SJ cbx_lpm_compare 2018:09:12:13:04:09:SJ cbx_lpm_mult 2018:09:12:13:04:09:SJ cbx_lpm_mux 2018:09:12:13:04:09:SJ cbx_mgl 2018:09:12:14:15:07:SJ cbx_nadder 2018:09:12:13:04:09:SJ cbx_padd 2018:09:12:13:04:09:SJ cbx_stratix 2018:09:12:13:04:09:SJ cbx_stratixii 2018:09:12:13:04:09:SJ cbx_util_mgl 2018:09:12:13:04:09:SJ  VERSION_END

//synthesis_resources = reg 6 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  inverse_altfp_inv_and_or_ckd
	( 
	aclr,
	clken,
	clock,
	data,
	result) ;
	input   aclr;
	input   clken;
	input   clock;
	input   [22:0]  data;
	output   result;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0   aclr;
	tri1   clken;
	tri0   clock;
	tri0   [22:0]  data;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	reg	[3:0]	connection_dffe0;
	reg	[0:0]	connection_dffe1;
	reg	connection_dffe2;
	wire  [22:0]  connection_r0_w;
	wire  [3:0]  connection_r1_w;
	wire  [0:0]  connection_r2_w;
	wire  [22:0]  operation_r1_w;
	wire  [3:0]  operation_r2_w;

	// synopsys translate_off
	initial
		connection_dffe0 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe0 <= 4'b0;
		else if  (clken == 1'b1)   connection_dffe0 <= {operation_r1_w[22], operation_r1_w[17], operation_r1_w[11], operation_r1_w[5]};
	// synopsys translate_off
	initial
		connection_dffe1 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe1 <= 1'b0;
		else if  (clken == 1'b1)   connection_dffe1 <= {operation_r2_w[3]};
	// synopsys translate_off
	initial
		connection_dffe2 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe2 <= 1'b0;
		else if  (clken == 1'b1)   connection_dffe2 <= connection_r2_w[0];
	assign
		connection_r0_w = data,
		connection_r1_w = connection_dffe0,
		connection_r2_w = connection_dffe1,
		operation_r1_w = {(operation_r1_w[21] | connection_r0_w[22]), (operation_r1_w[20] | connection_r0_w[21]), (operation_r1_w[19] | connection_r0_w[20]), (operation_r1_w[18] | connection_r0_w[19]), connection_r0_w[18], (operation_r1_w[16] | connection_r0_w[17]), (operation_r1_w[15] | connection_r0_w[16]), (operation_r1_w[14] | connection_r0_w[15]), (operation_r1_w[13] | connection_r0_w[14]), (operation_r1_w[12] | connection_r0_w[13]), connection_r0_w[12], (operation_r1_w[10] | connection_r0_w[11]), (operation_r1_w[9] | connection_r0_w[10]), (operation_r1_w[8] | connection_r0_w[9]), (operation_r1_w[7] | connection_r0_w[8]), (operation_r1_w[6] | connection_r0_w[7]), connection_r0_w[6], (operation_r1_w[4] | connection_r0_w[5]), (operation_r1_w[3] | connection_r0_w[4]), (operation_r1_w[2] | connection_r0_w[3]), (operation_r1_w[1] | connection_r0_w[2]), (operation_r1_w[0] | connection_r0_w[1]), connection_r0_w[0]},
		operation_r2_w = {(operation_r2_w[2] | connection_r1_w[3]), (operation_r2_w[1] | connection_r1_w[2]), (operation_r2_w[0] | connection_r1_w[1]), connection_r1_w[0]},
		result = connection_dffe2;
endmodule //inverse_altfp_inv_and_or_ckd


//altfp_inv_and_or CBX_AUTO_BLACKBOX="ALL" DEVICE_FAMILY="Cyclone V" LUT_INPUT_COUNT=6 OPERATION="AND" PIPELINE=3 WIDTH=23 aclr clken clock data result
//VERSION_BEGIN 18.1 cbx_altfp_inv 2018:09:12:13:04:09:SJ cbx_cycloneii 2018:09:12:13:04:09:SJ cbx_lpm_add_sub 2018:09:12:13:04:09:SJ cbx_lpm_compare 2018:09:12:13:04:09:SJ cbx_lpm_mult 2018:09:12:13:04:09:SJ cbx_lpm_mux 2018:09:12:13:04:09:SJ cbx_mgl 2018:09:12:14:15:07:SJ cbx_nadder 2018:09:12:13:04:09:SJ cbx_padd 2018:09:12:13:04:09:SJ cbx_stratix 2018:09:12:13:04:09:SJ cbx_stratixii 2018:09:12:13:04:09:SJ cbx_util_mgl 2018:09:12:13:04:09:SJ  VERSION_END

//synthesis_resources = reg 6 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  inverse_altfp_inv_and_or_umd
	( 
	aclr,
	clken,
	clock,
	data,
	result) ;
	input   aclr;
	input   clken;
	input   clock;
	input   [22:0]  data;
	output   result;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0   aclr;
	tri1   clken;
	tri0   clock;
	tri0   [22:0]  data;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	reg	[3:0]	connection_dffe0;
	reg	[0:0]	connection_dffe1;
	reg	connection_dffe2;
	wire  [22:0]  connection_r0_w;
	wire  [3:0]  connection_r1_w;
	wire  [0:0]  connection_r2_w;
	wire  [22:0]  operation_r1_w;
	wire  [3:0]  operation_r2_w;

	// synopsys translate_off
	initial
		connection_dffe0 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe0 <= 4'b0;
		else if  (clken == 1'b1)   connection_dffe0 <= {operation_r1_w[22], operation_r1_w[17], operation_r1_w[11], operation_r1_w[5]};
	// synopsys translate_off
	initial
		connection_dffe1 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe1 <= 1'b0;
		else if  (clken == 1'b1)   connection_dffe1 <= {operation_r2_w[3]};
	// synopsys translate_off
	initial
		connection_dffe2 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe2 <= 1'b0;
		else if  (clken == 1'b1)   connection_dffe2 <= connection_r2_w[0];
	assign
		connection_r0_w = data,
		connection_r1_w = connection_dffe0,
		connection_r2_w = connection_dffe1,
		operation_r1_w = {(operation_r1_w[21] & connection_r0_w[22]), (operation_r1_w[20] & connection_r0_w[21]), (operation_r1_w[19] & connection_r0_w[20]), (operation_r1_w[18] & connection_r0_w[19]), connection_r0_w[18], (operation_r1_w[16] & connection_r0_w[17]), (operation_r1_w[15] & connection_r0_w[16]), (operation_r1_w[14] & connection_r0_w[15]), (operation_r1_w[13] & connection_r0_w[14]), (operation_r1_w[12] & connection_r0_w[13]), connection_r0_w[12], (operation_r1_w[10] & connection_r0_w[11]), (operation_r1_w[9] & connection_r0_w[10]), (operation_r1_w[8] & connection_r0_w[9]), (operation_r1_w[7] & connection_r0_w[8]), (operation_r1_w[6] & connection_r0_w[7]), connection_r0_w[6], (operation_r1_w[4] & connection_r0_w[5]), (operation_r1_w[3] & connection_r0_w[4]), (operation_r1_w[2] & connection_r0_w[3]), (operation_r1_w[1] & connection_r0_w[2]), (operation_r1_w[0] & connection_r0_w[1]), connection_r0_w[0]},
		operation_r2_w = {(operation_r2_w[2] & connection_r1_w[3]), (operation_r2_w[1] & connection_r1_w[2]), (operation_r2_w[0] & connection_r1_w[1]), connection_r1_w[0]},
		result = connection_dffe2;
endmodule //inverse_altfp_inv_and_or_umd


//altfp_inv_and_or CBX_AUTO_BLACKBOX="ALL" DEVICE_FAMILY="Cyclone V" LUT_INPUT_COUNT=6 OPERATION="OR" PIPELINE=3 WIDTH=8 aclr clken clock data result
//VERSION_BEGIN 18.1 cbx_altfp_inv 2018:09:12:13:04:09:SJ cbx_cycloneii 2018:09:12:13:04:09:SJ cbx_lpm_add_sub 2018:09:12:13:04:09:SJ cbx_lpm_compare 2018:09:12:13:04:09:SJ cbx_lpm_mult 2018:09:12:13:04:09:SJ cbx_lpm_mux 2018:09:12:13:04:09:SJ cbx_mgl 2018:09:12:14:15:07:SJ cbx_nadder 2018:09:12:13:04:09:SJ cbx_padd 2018:09:12:13:04:09:SJ cbx_stratix 2018:09:12:13:04:09:SJ cbx_stratixii 2018:09:12:13:04:09:SJ cbx_util_mgl 2018:09:12:13:04:09:SJ  VERSION_END

//synthesis_resources = reg 4 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  inverse_altfp_inv_and_or_vid
	( 
	aclr,
	clken,
	clock,
	data,
	result) ;
	input   aclr;
	input   clken;
	input   clock;
	input   [7:0]  data;
	output   result;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0   aclr;
	tri1   clken;
	tri0   clock;
	tri0   [7:0]  data;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	reg	[1:0]	connection_dffe0;
	reg	[0:0]	connection_dffe1;
	reg	connection_dffe2;
	wire  [7:0]  connection_r0_w;
	wire  [1:0]  connection_r1_w;
	wire  [0:0]  connection_r2_w;
	wire  [7:0]  operation_r1_w;
	wire  [1:0]  operation_r2_w;

	// synopsys translate_off
	initial
		connection_dffe0 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe0 <= 2'b0;
		else if  (clken == 1'b1)   connection_dffe0 <= {operation_r1_w[7], operation_r1_w[5]};
	// synopsys translate_off
	initial
		connection_dffe1 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe1 <= 1'b0;
		else if  (clken == 1'b1)   connection_dffe1 <= {operation_r2_w[1]};
	// synopsys translate_off
	initial
		connection_dffe2 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe2 <= 1'b0;
		else if  (clken == 1'b1)   connection_dffe2 <= connection_r2_w[0];
	assign
		connection_r0_w = data,
		connection_r1_w = connection_dffe0,
		connection_r2_w = connection_dffe1,
		operation_r1_w = {(operation_r1_w[6] | connection_r0_w[7]), connection_r0_w[6], (operation_r1_w[4] | connection_r0_w[5]), (operation_r1_w[3] | connection_r0_w[4]), (operation_r1_w[2] | connection_r0_w[3]), (operation_r1_w[1] | connection_r0_w[2]), (operation_r1_w[0] | connection_r0_w[1]), connection_r0_w[0]},
		operation_r2_w = {(operation_r2_w[0] | connection_r1_w[1]), connection_r1_w[0]},
		result = connection_dffe2;
endmodule //inverse_altfp_inv_and_or_vid


//altfp_inv_and_or CBX_AUTO_BLACKBOX="ALL" DEVICE_FAMILY="Cyclone V" LUT_INPUT_COUNT=6 OPERATION="AND" PIPELINE=3 WIDTH=8 aclr clken clock data result
//VERSION_BEGIN 18.1 cbx_altfp_inv 2018:09:12:13:04:09:SJ cbx_cycloneii 2018:09:12:13:04:09:SJ cbx_lpm_add_sub 2018:09:12:13:04:09:SJ cbx_lpm_compare 2018:09:12:13:04:09:SJ cbx_lpm_mult 2018:09:12:13:04:09:SJ cbx_lpm_mux 2018:09:12:13:04:09:SJ cbx_mgl 2018:09:12:14:15:07:SJ cbx_nadder 2018:09:12:13:04:09:SJ cbx_padd 2018:09:12:13:04:09:SJ cbx_stratix 2018:09:12:13:04:09:SJ cbx_stratixii 2018:09:12:13:04:09:SJ cbx_util_mgl 2018:09:12:13:04:09:SJ  VERSION_END

//synthesis_resources = reg 4 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  inverse_altfp_inv_and_or_hld
	( 
	aclr,
	clken,
	clock,
	data,
	result) ;
	input   aclr;
	input   clken;
	input   clock;
	input   [7:0]  data;
	output   result;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0   aclr;
	tri1   clken;
	tri0   clock;
	tri0   [7:0]  data;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	reg	[1:0]	connection_dffe0;
	reg	[0:0]	connection_dffe1;
	reg	connection_dffe2;
	wire  [7:0]  connection_r0_w;
	wire  [1:0]  connection_r1_w;
	wire  [0:0]  connection_r2_w;
	wire  [7:0]  operation_r1_w;
	wire  [1:0]  operation_r2_w;

	// synopsys translate_off
	initial
		connection_dffe0 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe0 <= 2'b0;
		else if  (clken == 1'b1)   connection_dffe0 <= {operation_r1_w[7], operation_r1_w[5]};
	// synopsys translate_off
	initial
		connection_dffe1 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe1 <= 1'b0;
		else if  (clken == 1'b1)   connection_dffe1 <= {operation_r2_w[1]};
	// synopsys translate_off
	initial
		connection_dffe2 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe2 <= 1'b0;
		else if  (clken == 1'b1)   connection_dffe2 <= connection_r2_w[0];
	assign
		connection_r0_w = data,
		connection_r1_w = connection_dffe0,
		connection_r2_w = connection_dffe1,
		operation_r1_w = {(operation_r1_w[6] & connection_r0_w[7]), connection_r0_w[6], (operation_r1_w[4] & connection_r0_w[5]), (operation_r1_w[3] & connection_r0_w[4]), (operation_r1_w[2] & connection_r0_w[3]), (operation_r1_w[1] & connection_r0_w[2]), (operation_r1_w[0] & connection_r0_w[1]), connection_r0_w[0]},
		operation_r2_w = {(operation_r2_w[0] & connection_r1_w[1]), connection_r1_w[0]},
		result = connection_dffe2;
endmodule //inverse_altfp_inv_and_or_hld


//altfp_inv_csa CARRY_SELECT="YES" CBX_AUTO_BLACKBOX="ALL" DEVICE_FAMILY="Cyclone V" DIRECTION="SUB" PIPELINE=1 REGISTER_INPUT="NO" REPRESENTATION="UNSIGNED" WIDTH=26 aclr clken clock dataa datab result
//VERSION_BEGIN 18.1 cbx_altfp_inv 2018:09:12:13:04:09:SJ cbx_cycloneii 2018:09:12:13:04:09:SJ cbx_lpm_add_sub 2018:09:12:13:04:09:SJ cbx_lpm_compare 2018:09:12:13:04:09:SJ cbx_lpm_mult 2018:09:12:13:04:09:SJ cbx_lpm_mux 2018:09:12:13:04:09:SJ cbx_mgl 2018:09:12:14:15:07:SJ cbx_nadder 2018:09:12:13:04:09:SJ cbx_padd 2018:09:12:13:04:09:SJ cbx_stratix 2018:09:12:13:04:09:SJ cbx_stratixii 2018:09:12:13:04:09:SJ cbx_util_mgl 2018:09:12:13:04:09:SJ  VERSION_END

//synthesis_resources = lpm_add_sub 3 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  inverse_altfp_inv_csa_tbi
	( 
	aclr,
	clken,
	clock,
	dataa,
	datab,
	result) ;
	input   aclr;
	input   clken;
	input   clock;
	input   [25:0]  dataa;
	input   [25:0]  datab;
	output   [25:0]  result;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0   aclr;
	tri1   clken;
	tri0   clock;
	tri0   [25:0]  dataa;
	tri0   [25:0]  datab;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	wire  wire_csa_lower_cout;
	wire  [12:0]   wire_csa_lower_result;
	wire  [12:0]   wire_csa_upper0_result;
	wire  [12:0]   wire_csa_upper1_result;
	wire  [25:0]  dataa_w;
	wire  [25:0]  datab_w;
	wire  [25:0]  result_w;

	lpm_add_sub   csa_lower
	( 
	.aclr(aclr),
	.clken(clken),
	.clock(clock),
	.cout(wire_csa_lower_cout),
	.dataa(dataa_w[12:0]),
	.datab(datab_w[12:0]),
	.overflow(),
	.result(wire_csa_lower_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1),
	.cin()
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		csa_lower.lpm_direction = "SUB",
		csa_lower.lpm_pipeline = 1,
		csa_lower.lpm_representation = "UNSIGNED",
		csa_lower.lpm_width = 13,
		csa_lower.lpm_type = "lpm_add_sub";
	lpm_add_sub   csa_upper0
	( 
	.aclr(aclr),
	.cin(1'b0),
	.clken(clken),
	.clock(clock),
	.cout(),
	.dataa(dataa_w[25:13]),
	.datab(datab_w[25:13]),
	.overflow(),
	.result(wire_csa_upper0_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		csa_upper0.lpm_direction = "SUB",
		csa_upper0.lpm_pipeline = 1,
		csa_upper0.lpm_representation = "UNSIGNED",
		csa_upper0.lpm_width = 13,
		csa_upper0.lpm_type = "lpm_add_sub";
	lpm_add_sub   csa_upper1
	( 
	.aclr(aclr),
	.cin(1'b1),
	.clken(clken),
	.clock(clock),
	.cout(),
	.dataa(dataa_w[25:13]),
	.datab(datab_w[25:13]),
	.overflow(),
	.result(wire_csa_upper1_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		csa_upper1.lpm_direction = "SUB",
		csa_upper1.lpm_pipeline = 1,
		csa_upper1.lpm_representation = "UNSIGNED",
		csa_upper1.lpm_width = 13,
		csa_upper1.lpm_type = "lpm_add_sub";
	assign
		dataa_w = dataa,
		datab_w = datab,
		result = result_w,
		result_w = {(({13{(~ wire_csa_lower_cout)}} & wire_csa_upper0_result) | ({13{wire_csa_lower_cout}} & wire_csa_upper1_result)), wire_csa_lower_result};
endmodule //inverse_altfp_inv_csa_tbi


//altfp_inv_csa CARRY_SELECT="NO" CBX_AUTO_BLACKBOX="ALL" DEVICE_FAMILY="Cyclone V" DIRECTION="ADD" PIPELINE=1 REGISTER_INPUT="NO" REPRESENTATION="UNSIGNED" WIDTH=13 aclr clken clock dataa datab result
//VERSION_BEGIN 18.1 cbx_altfp_inv 2018:09:12:13:04:09:SJ cbx_cycloneii 2018:09:12:13:04:09:SJ cbx_lpm_add_sub 2018:09:12:13:04:09:SJ cbx_lpm_compare 2018:09:12:13:04:09:SJ cbx_lpm_mult 2018:09:12:13:04:09:SJ cbx_lpm_mux 2018:09:12:13:04:09:SJ cbx_mgl 2018:09:12:14:15:07:SJ cbx_nadder 2018:09:12:13:04:09:SJ cbx_padd 2018:09:12:13:04:09:SJ cbx_stratix 2018:09:12:13:04:09:SJ cbx_stratixii 2018:09:12:13:04:09:SJ cbx_util_mgl 2018:09:12:13:04:09:SJ  VERSION_END

//synthesis_resources = lpm_add_sub 1 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  inverse_altfp_inv_csa_47i
	( 
	aclr,
	clken,
	clock,
	dataa,
	datab,
	result) ;
	input   aclr;
	input   clken;
	input   clock;
	input   [12:0]  dataa;
	input   [12:0]  datab;
	output   [12:0]  result;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0   aclr;
	tri1   clken;
	tri0   clock;
	tri0   [12:0]  dataa;
	tri0   [12:0]  datab;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	wire  [12:0]   wire_add_sub7_result;
	wire  [12:0]  dataa_w;
	wire  [12:0]  datab_w;
	wire  [12:0]  result_w;

	lpm_add_sub   add_sub7
	( 
	.aclr(aclr),
	.clken(clken),
	.clock(clock),
	.cout(),
	.dataa(dataa_w),
	.datab(datab_w),
	.overflow(),
	.result(wire_add_sub7_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1),
	.cin()
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		add_sub7.lpm_direction = "ADD",
		add_sub7.lpm_pipeline = 1,
		add_sub7.lpm_representation = "UNSIGNED",
		add_sub7.lpm_width = 13,
		add_sub7.lpm_type = "lpm_add_sub";
	assign
		dataa_w = dataa,
		datab_w = datab,
		result = result_w,
		result_w = wire_add_sub7_result;
endmodule //inverse_altfp_inv_csa_47i


//altfp_inv_csa CARRY_SELECT="NO" CBX_AUTO_BLACKBOX="ALL" DEVICE_FAMILY="Cyclone V" DIRECTION="SUB" PIPELINE=1 REGISTER_INPUT="NO" REPRESENTATION="UNSIGNED" WIDTH=13 aclr clken clock dataa datab result
//VERSION_BEGIN 18.1 cbx_altfp_inv 2018:09:12:13:04:09:SJ cbx_cycloneii 2018:09:12:13:04:09:SJ cbx_lpm_add_sub 2018:09:12:13:04:09:SJ cbx_lpm_compare 2018:09:12:13:04:09:SJ cbx_lpm_mult 2018:09:12:13:04:09:SJ cbx_lpm_mux 2018:09:12:13:04:09:SJ cbx_mgl 2018:09:12:14:15:07:SJ cbx_nadder 2018:09:12:13:04:09:SJ cbx_padd 2018:09:12:13:04:09:SJ cbx_stratix 2018:09:12:13:04:09:SJ cbx_stratixii 2018:09:12:13:04:09:SJ cbx_util_mgl 2018:09:12:13:04:09:SJ  VERSION_END

//synthesis_resources = lpm_add_sub 1 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  inverse_altfp_inv_csa_58i
	( 
	aclr,
	clken,
	clock,
	dataa,
	datab,
	result) ;
	input   aclr;
	input   clken;
	input   clock;
	input   [12:0]  dataa;
	input   [12:0]  datab;
	output   [12:0]  result;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0   aclr;
	tri1   clken;
	tri0   clock;
	tri0   [12:0]  dataa;
	tri0   [12:0]  datab;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	wire  [12:0]   wire_add_sub8_result;
	wire  [12:0]  dataa_w;
	wire  [12:0]  datab_w;
	wire  [12:0]  result_w;

	lpm_add_sub   add_sub8
	( 
	.aclr(aclr),
	.clken(clken),
	.clock(clock),
	.cout(),
	.dataa(dataa_w),
	.datab(datab_w),
	.overflow(),
	.result(wire_add_sub8_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1),
	.cin()
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		add_sub8.lpm_direction = "SUB",
		add_sub8.lpm_pipeline = 1,
		add_sub8.lpm_representation = "UNSIGNED",
		add_sub8.lpm_width = 13,
		add_sub8.lpm_type = "lpm_add_sub";
	assign
		dataa_w = dataa,
		datab_w = datab,
		result = result_w,
		result_w = wire_add_sub8_result;
endmodule //inverse_altfp_inv_csa_58i

//synthesis_resources = lpm_add_sub 15 lpm_compare 1 lpm_mult 4 lpm_mux 1 reg 749 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  inverse_altfp_inv_vec
	( 
	clock,
	data,
	result) ;
	input   clock;
	input   [31:0]  data;
	output   [31:0]  result;

	wire  wire_altfp_inv_and_or2_result;
	wire  wire_altfp_inv_and_or3_result;
	wire  wire_altfp_inv_and_or4_result;
	wire  wire_altfp_inv_and_or5_result;
	wire  [25:0]   wire_diff_adder_0_result;
	wire  [25:0]   wire_diff_adder_1_result;
	wire  [12:0]   wire_slope_r1c1_add_result;
	wire  [12:0]   wire_slope_r1c2_add_result;
	wire  [12:0]   wire_slope_r1c3_add_result;
	wire  [12:0]   wire_slope_r2c1_add_result;
	wire  [12:0]   wire_slope_r2c2_add_result;
	wire  [12:0]   wire_slope_r3c1_add_result;
	reg	[12:0]	and_dffe_0;
	reg	[12:0]	and_dffe_1;
	reg	[12:0]	and_dffe_2;
	reg	[12:0]	and_dffe_3;
	reg	[12:0]	and_dffe_4;
	reg	[12:0]	and_dffe_5;
	reg	[2:0]	division_by_zero_dffe;
	reg	[7:0]	exp_dffe1_0;
	reg	[7:0]	exp_dffe1_1;
	reg	[7:0]	exp_dffe1_10;
	reg	[7:0]	exp_dffe1_11;
	reg	[7:0]	exp_dffe1_12;
	reg	[7:0]	exp_dffe1_13;
	reg	[7:0]	exp_dffe1_14;
	reg	[7:0]	exp_dffe1_2;
	reg	[7:0]	exp_dffe1_3;
	reg	[7:0]	exp_dffe1_4;
	reg	[7:0]	exp_dffe1_5;
	reg	[7:0]	exp_dffe1_6;
	reg	[7:0]	exp_dffe1_7;
	reg	[7:0]	exp_dffe1_8;
	reg	[7:0]	exp_dffe1_9;
	reg	[7:0]	exp_dffe2_0;
	reg	[7:0]	exp_dffe2_1;
	reg	[7:0]	exp_dffe2_2;
	reg	[2:0]	infinite_dffe;
	reg	infinite_input_dffe;
	reg	[9:0]	intercept_dffe;
	reg	[22:0]	man_dffe_0;
	reg	[22:0]	man_dffe_1;
	reg	[22:0]	man_dffe_10;
	reg	[22:0]	man_dffe_11;
	reg	[22:0]	man_dffe_2;
	reg	[22:0]	man_dffe_3;
	reg	[22:0]	man_dffe_4;
	reg	[22:0]	man_dffe_5;
	reg	[22:0]	man_dffe_6;
	reg	[22:0]	man_dffe_7;
	reg	[22:0]	man_dffe_8;
	reg	[22:0]	man_dffe_9;
	reg	[2:0]	nan_dffe;
	reg	nan_input_dffe;
	reg	[31:0]	result_output_dffe;
	reg	[18:0]	sign_dffe;
	reg	[2:0]	underflow_dffe;
	reg	[12:0]	x_dffe_0;
	reg	[12:0]	x_dffe_1;
	reg	[12:0]	x_dffe_2;
	reg	[12:0]	x_dffe_3;
	reg	[24:0]	x_dffe_4;
	reg	[24:0]	x_dffe_5;
	reg	[24:0]	x_dffe_6;
	reg	[24:0]	x_dffe_7;
	reg	[2:0]	zero_dffe;
	reg	zero_input_dffe;
	wire  [6:0]   wire_approx_sub_result;
	wire  [8:0]   wire_bias_adjustment_result;
	wire  [12:0]   wire_modified_add_result;
	wire  wire_cmpr6_ageb;
	wire  [36:0]   wire_inner_mult0_result;
	wire  [48:0]   wire_inner_mult1_result;
	wire  [37:0]   wire_outer_mult0_result;
	wire  [49:0]   wire_outer_mult1_result;
	wire  [15:0]   wire_mux1_result;
	wire aclr;
	wire  [29:0]  and_b0_w;
	wire  [29:0]  and_b1_w;
	wire  [29:0]  and_b2_w;
	wire  [29:0]  and_b3_w;
	wire  [29:0]  and_b4_w;
	wire  [29:0]  and_b5_w;
	wire  [6:0]  approx_c_w;
	wire  [6:0]  approx_mx_w;
	wire  [12:0]  approx_y_w;
	wire  [12:0]  c_offset_w;
	wire clk_en;
	wire  [25:0]  const_2_w;
	wire  [8:0]  const_bias_adj_greater_one_w;
	wire  [8:0]  const_bias_adj_one_w;
	wire  [8:0]  const_bias_adj_w;
	wire  [7:0]  data_exp_bus_w;
	wire  [22:0]  data_man_bus_w;
	wire  data_sign_w;
	wire  division_by_zero_w;
	wire  exp_and_msb_w;
	wire  [7:0]  exp_bus_w;
	wire  [7:0]  exp_exc_ones_w;
	wire  [7:0]  exp_exc_zeros_w;
	wire  exp_one_w;
	wire  exp_or_msb_w;
	wire  [7:0]  exp_res_w;
	wire  exp_zero_w;
	wire  gnd_w;
	wire  [31:0]  infi_res_w;
	wire  infinite_input_w;
	wire  infinite_out_w;
	wire  infinite_w;
	wire  man_and_msb_w;
	wire  [22:0]  man_bus_w;
	wire  [22:0]  man_exc_nan_w;
	wire  [22:0]  man_exc_zeros_w;
	wire  man_non_zero_w;
	wire  man_one_w;
	wire  man_or_msb_w;
	wire  [23:0]  man_out_0_w;
	wire  [23:0]  man_out_1_w;
	wire  [22:0]  man_res_w;
	wire  man_zero_w;
	wire  [12:0]  modified_c_w;
	wire  [31:0]  mux_1_res_w;
	wire  [31:0]  mux_2_res_w;
	wire  [31:0]  mux_3_res_w;
	wire  nan_input_w;
	wire  nan_out_w;
	wire  [31:0]  nan_res_w;
	wire  nan_w;
	wire  [31:0]  norm_res_int_w;
	wire  [29:0]  shift_b0_w;
	wire  [29:0]  shift_b1_w;
	wire  [29:0]  shift_b2_w;
	wire  [29:0]  shift_b3_w;
	wire  [29:0]  shift_b4_w;
	wire  [29:0]  shift_b5_w;
	wire  sign_exc_bit_w;
	wire  sign_res_w;
	wire  [5:0]  slope_w;
	wire  [511:0]  table_bus_full_w;
	wire  underflow_w;
	wire  vcc_w;
	wire  [12:0]  x_0_w;
	wire  [24:0]  x_1_w;
	wire  [24:0]  x_2_w;
	wire  [12:0]  x_initial_w;
	wire  zero_input_w;
	wire  zero_out_w;
	wire  [31:0]  zero_res_w;
	wire  zero_w;

	inverse_altfp_inv_and_or_ckd   altfp_inv_and_or2
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.data(man_bus_w),
	.result(wire_altfp_inv_and_or2_result));
	inverse_altfp_inv_and_or_umd   altfp_inv_and_or3
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.data(man_bus_w),
	.result(wire_altfp_inv_and_or3_result));
	inverse_altfp_inv_and_or_vid   altfp_inv_and_or4
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.data(exp_bus_w),
	.result(wire_altfp_inv_and_or4_result));
	inverse_altfp_inv_and_or_hld   altfp_inv_and_or5
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.data(exp_bus_w),
	.result(wire_altfp_inv_and_or5_result));
	inverse_altfp_inv_csa_tbi   diff_adder_0
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(const_2_w[25:0]),
	.datab(wire_inner_mult0_result[36:11]),
	.result(wire_diff_adder_0_result));
	inverse_altfp_inv_csa_tbi   diff_adder_1
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(const_2_w[25:0]),
	.datab(wire_inner_mult1_result[48:23]),
	.result(wire_diff_adder_1_result));
	inverse_altfp_inv_csa_47i   slope_r1c1_add
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(and_dffe_0),
	.datab(and_dffe_1),
	.result(wire_slope_r1c1_add_result));
	inverse_altfp_inv_csa_47i   slope_r1c2_add
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(and_dffe_2),
	.datab(and_dffe_3),
	.result(wire_slope_r1c2_add_result));
	inverse_altfp_inv_csa_47i   slope_r1c3_add
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(and_dffe_4),
	.datab(and_dffe_5),
	.result(wire_slope_r1c3_add_result));
	inverse_altfp_inv_csa_47i   slope_r2c1_add
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(wire_slope_r1c1_add_result),
	.datab(wire_slope_r1c2_add_result),
	.result(wire_slope_r2c1_add_result));
	inverse_altfp_inv_csa_58i   slope_r2c2_add
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(modified_c_w),
	.datab(wire_slope_r1c3_add_result),
	.result(wire_slope_r2c2_add_result));
	inverse_altfp_inv_csa_58i   slope_r3c1_add
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(wire_slope_r2c2_add_result),
	.datab(wire_slope_r2c1_add_result),
	.result(wire_slope_r3c1_add_result));
	// synopsys translate_off
	initial
		and_dffe_0 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) and_dffe_0 <= 13'b0;
		else if  (clk_en == 1'b1)   and_dffe_0 <= and_b0_w[29:17];
	// synopsys translate_off
	initial
		and_dffe_1 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) and_dffe_1 <= 13'b0;
		else if  (clk_en == 1'b1)   and_dffe_1 <= and_b1_w[29:17];
	// synopsys translate_off
	initial
		and_dffe_2 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) and_dffe_2 <= 13'b0;
		else if  (clk_en == 1'b1)   and_dffe_2 <= and_b2_w[29:17];
	// synopsys translate_off
	initial
		and_dffe_3 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) and_dffe_3 <= 13'b0;
		else if  (clk_en == 1'b1)   and_dffe_3 <= and_b3_w[29:17];
	// synopsys translate_off
	initial
		and_dffe_4 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) and_dffe_4 <= 13'b0;
		else if  (clk_en == 1'b1)   and_dffe_4 <= and_b4_w[29:17];
	// synopsys translate_off
	initial
		and_dffe_5 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) and_dffe_5 <= 13'b0;
		else if  (clk_en == 1'b1)   and_dffe_5 <= and_b5_w[29:17];
	// synopsys translate_off
	initial
		division_by_zero_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) division_by_zero_dffe <= 3'b0;
		else if  (clk_en == 1'b1)   division_by_zero_dffe <= {division_by_zero_dffe[1:0], division_by_zero_w};
	// synopsys translate_off
	initial
		exp_dffe1_0 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_0 <= 8'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_0 <= data_exp_bus_w;
	// synopsys translate_off
	initial
		exp_dffe1_1 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_1 <= 8'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_1 <= exp_dffe1_0;
	// synopsys translate_off
	initial
		exp_dffe1_10 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_10 <= 8'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_10 <= exp_dffe1_9;
	// synopsys translate_off
	initial
		exp_dffe1_11 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_11 <= 8'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_11 <= exp_dffe1_10;
	// synopsys translate_off
	initial
		exp_dffe1_12 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_12 <= 8'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_12 <= exp_dffe1_11;
	// synopsys translate_off
	initial
		exp_dffe1_13 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_13 <= 8'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_13 <= exp_dffe1_12;
	// synopsys translate_off
	initial
		exp_dffe1_14 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_14 <= 8'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_14 <= exp_dffe1_13;
	// synopsys translate_off
	initial
		exp_dffe1_2 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_2 <= 8'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_2 <= exp_dffe1_1;
	// synopsys translate_off
	initial
		exp_dffe1_3 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_3 <= 8'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_3 <= exp_dffe1_2;
	// synopsys translate_off
	initial
		exp_dffe1_4 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_4 <= 8'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_4 <= exp_dffe1_3;
	// synopsys translate_off
	initial
		exp_dffe1_5 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_5 <= 8'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_5 <= exp_dffe1_4;
	// synopsys translate_off
	initial
		exp_dffe1_6 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_6 <= 8'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_6 <= exp_dffe1_5;
	// synopsys translate_off
	initial
		exp_dffe1_7 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_7 <= 8'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_7 <= exp_dffe1_6;
	// synopsys translate_off
	initial
		exp_dffe1_8 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_8 <= 8'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_8 <= exp_dffe1_7;
	// synopsys translate_off
	initial
		exp_dffe1_9 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_9 <= 8'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_9 <= exp_dffe1_8;
	// synopsys translate_off
	initial
		exp_dffe2_0 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe2_0 <= 8'b0;
		else if  (clk_en == 1'b1)   exp_dffe2_0 <= wire_bias_adjustment_result[7:0];
	// synopsys translate_off
	initial
		exp_dffe2_1 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe2_1 <= 8'b0;
		else if  (clk_en == 1'b1)   exp_dffe2_1 <= exp_dffe2_0;
	// synopsys translate_off
	initial
		exp_dffe2_2 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe2_2 <= 8'b0;
		else if  (clk_en == 1'b1)   exp_dffe2_2 <= exp_dffe2_1;
	// synopsys translate_off
	initial
		infinite_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) infinite_dffe <= 3'b0;
		else if  (clk_en == 1'b1)   infinite_dffe <= {infinite_dffe[1:0], infinite_w};
	// synopsys translate_off
	initial
		infinite_input_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) infinite_input_dffe <= 1'b0;
		else if  (clk_en == 1'b1)   infinite_input_dffe <= (exp_one_w & man_zero_w);
	// synopsys translate_off
	initial
		intercept_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) intercept_dffe <= 10'b0;
		else if  (clk_en == 1'b1)   intercept_dffe <= wire_mux1_result[9:0];
	// synopsys translate_off
	initial
		man_dffe_0 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_0 <= 23'b0;
		else if  (clk_en == 1'b1)   man_dffe_0 <= data_man_bus_w;
	// synopsys translate_off
	initial
		man_dffe_1 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_1 <= 23'b0;
		else if  (clk_en == 1'b1)   man_dffe_1 <= man_dffe_0;
	// synopsys translate_off
	initial
		man_dffe_10 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_10 <= 23'b0;
		else if  (clk_en == 1'b1)   man_dffe_10 <= man_dffe_9;
	// synopsys translate_off
	initial
		man_dffe_11 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_11 <= 23'b0;
		else if  (clk_en == 1'b1)   man_dffe_11 <= man_dffe_10;
	// synopsys translate_off
	initial
		man_dffe_2 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_2 <= 23'b0;
		else if  (clk_en == 1'b1)   man_dffe_2 <= man_dffe_1;
	// synopsys translate_off
	initial
		man_dffe_3 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_3 <= 23'b0;
		else if  (clk_en == 1'b1)   man_dffe_3 <= man_dffe_2;
	// synopsys translate_off
	initial
		man_dffe_4 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_4 <= 23'b0;
		else if  (clk_en == 1'b1)   man_dffe_4 <= man_dffe_3;
	// synopsys translate_off
	initial
		man_dffe_5 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_5 <= 23'b0;
		else if  (clk_en == 1'b1)   man_dffe_5 <= man_dffe_4;
	// synopsys translate_off
	initial
		man_dffe_6 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_6 <= 23'b0;
		else if  (clk_en == 1'b1)   man_dffe_6 <= man_dffe_5;
	// synopsys translate_off
	initial
		man_dffe_7 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_7 <= 23'b0;
		else if  (clk_en == 1'b1)   man_dffe_7 <= man_dffe_6;
	// synopsys translate_off
	initial
		man_dffe_8 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_8 <= 23'b0;
		else if  (clk_en == 1'b1)   man_dffe_8 <= man_dffe_7;
	// synopsys translate_off
	initial
		man_dffe_9 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_9 <= 23'b0;
		else if  (clk_en == 1'b1)   man_dffe_9 <= man_dffe_8;
	// synopsys translate_off
	initial
		nan_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) nan_dffe <= 3'b0;
		else if  (clk_en == 1'b1)   nan_dffe <= {nan_dffe[1:0], nan_w};
	// synopsys translate_off
	initial
		nan_input_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) nan_input_dffe <= 1'b0;
		else if  (clk_en == 1'b1)   nan_input_dffe <= (exp_one_w & (man_non_zero_w | man_one_w));
	// synopsys translate_off
	initial
		result_output_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) result_output_dffe <= 32'b0;
		else if  (clk_en == 1'b1)   result_output_dffe <= mux_3_res_w;
	// synopsys translate_off
	initial
		sign_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) sign_dffe <= 19'b0;
		else if  (clk_en == 1'b1)   sign_dffe <= {sign_dffe[17:0], data_sign_w};
	// synopsys translate_off
	initial
		underflow_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) underflow_dffe <= 3'b0;
		else if  (clk_en == 1'b1)   underflow_dffe <= {underflow_dffe[1:0], underflow_w};
	// synopsys translate_off
	initial
		x_dffe_0 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) x_dffe_0 <= 13'b0;
		else if  (clk_en == 1'b1)   x_dffe_0 <= x_0_w;
	// synopsys translate_off
	initial
		x_dffe_1 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) x_dffe_1 <= 13'b0;
		else if  (clk_en == 1'b1)   x_dffe_1 <= x_dffe_0;
	// synopsys translate_off
	initial
		x_dffe_2 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) x_dffe_2 <= 13'b0;
		else if  (clk_en == 1'b1)   x_dffe_2 <= x_dffe_1;
	// synopsys translate_off
	initial
		x_dffe_3 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) x_dffe_3 <= 13'b0;
		else if  (clk_en == 1'b1)   x_dffe_3 <= x_dffe_2;
	// synopsys translate_off
	initial
		x_dffe_4 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) x_dffe_4 <= 25'b0;
		else if  (clk_en == 1'b1)   x_dffe_4 <= x_1_w;
	// synopsys translate_off
	initial
		x_dffe_5 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) x_dffe_5 <= 25'b0;
		else if  (clk_en == 1'b1)   x_dffe_5 <= x_dffe_4;
	// synopsys translate_off
	initial
		x_dffe_6 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) x_dffe_6 <= 25'b0;
		else if  (clk_en == 1'b1)   x_dffe_6 <= x_dffe_5;
	// synopsys translate_off
	initial
		x_dffe_7 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) x_dffe_7 <= 25'b0;
		else if  (clk_en == 1'b1)   x_dffe_7 <= x_dffe_6;
	// synopsys translate_off
	initial
		zero_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) zero_dffe <= 3'b0;
		else if  (clk_en == 1'b1)   zero_dffe <= {zero_dffe[1:0], zero_w};
	// synopsys translate_off
	initial
		zero_input_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) zero_input_dffe <= 1'b0;
		else if  (clk_en == 1'b1)   zero_input_dffe <= (exp_zero_w & ((man_one_w | man_non_zero_w) | man_zero_w));
	lpm_add_sub   approx_sub
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.cout(),
	.dataa(approx_c_w),
	.datab(approx_mx_w),
	.overflow(),
	.result(wire_approx_sub_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1),
	.cin()
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		approx_sub.lpm_direction = "SUB",
		approx_sub.lpm_pipeline = 1,
		approx_sub.lpm_representation = "UNSIGNED",
		approx_sub.lpm_width = 7,
		approx_sub.lpm_type = "lpm_add_sub";
	lpm_add_sub   bias_adjustment
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.cout(),
	.dataa(const_bias_adj_w),
	.datab({gnd_w, exp_dffe1_14}),
	.overflow(),
	.result(wire_bias_adjustment_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1),
	.cin()
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		bias_adjustment.lpm_direction = "SUB",
		bias_adjustment.lpm_pipeline = 1,
		bias_adjustment.lpm_representation = "UNSIGNED",
		bias_adjustment.lpm_width = 9,
		bias_adjustment.lpm_type = "lpm_add_sub",
		bias_adjustment.lpm_hint = "ONE_INPUT_IS_CONSTANT=YES";
	lpm_add_sub   modified_add
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.cout(),
	.dataa(approx_y_w),
	.datab(c_offset_w),
	.overflow(),
	.result(wire_modified_add_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1),
	.cin()
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		modified_add.lpm_direction = "SUB",
		modified_add.lpm_pipeline = 1,
		modified_add.lpm_representation = "UNSIGNED",
		modified_add.lpm_width = 13,
		modified_add.lpm_type = "lpm_add_sub";
	lpm_compare   cmpr6
	( 
	.aclr(aclr),
	.aeb(),
	.agb(),
	.ageb(wire_cmpr6_ageb),
	.alb(),
	.aleb(),
	.aneb(),
	.clken(clk_en),
	.clock(clock),
	.dataa({gnd_w, exp_dffe1_14}),
	.datab(const_bias_adj_w));
	defparam
		cmpr6.lpm_pipeline = 1,
		cmpr6.lpm_representation = "UNSIGNED",
		cmpr6.lpm_width = 9,
		cmpr6.lpm_type = "lpm_compare";
	lpm_mult   inner_mult0
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(man_out_0_w),
	.datab(x_0_w),
	.result(wire_inner_mult0_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.sclr(1'b0),
	.sum({1{1'b0}})
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		inner_mult0.lpm_pipeline = 3,
		inner_mult0.lpm_representation = "UNSIGNED",
		inner_mult0.lpm_widtha = 24,
		inner_mult0.lpm_widthb = 13,
		inner_mult0.lpm_widthp = 37,
		inner_mult0.lpm_type = "lpm_mult",
		inner_mult0.lpm_hint = "DEDICATED_MULTIPLIER_CIRCUITRY=AUTO";
	lpm_mult   inner_mult1
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(man_out_1_w),
	.datab(x_1_w),
	.result(wire_inner_mult1_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.sclr(1'b0),
	.sum({1{1'b0}})
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		inner_mult1.lpm_pipeline = 3,
		inner_mult1.lpm_representation = "UNSIGNED",
		inner_mult1.lpm_widtha = 24,
		inner_mult1.lpm_widthb = 25,
		inner_mult1.lpm_widthp = 49,
		inner_mult1.lpm_type = "lpm_mult",
		inner_mult1.lpm_hint = "DEDICATED_MULTIPLIER_CIRCUITRY=AUTO";
	lpm_mult   outer_mult0
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(wire_diff_adder_0_result[24:0]),
	.datab(x_dffe_3),
	.result(wire_outer_mult0_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.sclr(1'b0),
	.sum({1{1'b0}})
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		outer_mult0.lpm_pipeline = 3,
		outer_mult0.lpm_representation = "UNSIGNED",
		outer_mult0.lpm_widtha = 25,
		outer_mult0.lpm_widthb = 13,
		outer_mult0.lpm_widthp = 38,
		outer_mult0.lpm_type = "lpm_mult",
		outer_mult0.lpm_hint = "DEDICATED_MULTIPLIER_CIRCUITRY=AUTO";
	lpm_mult   outer_mult1
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(wire_diff_adder_1_result[24:0]),
	.datab(x_dffe_7),
	.result(wire_outer_mult1_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.sclr(1'b0),
	.sum({1{1'b0}})
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		outer_mult1.lpm_pipeline = 3,
		outer_mult1.lpm_representation = "UNSIGNED",
		outer_mult1.lpm_widtha = 25,
		outer_mult1.lpm_widthb = 25,
		outer_mult1.lpm_widthp = 50,
		outer_mult1.lpm_type = "lpm_mult",
		outer_mult1.lpm_hint = "DEDICATED_MULTIPLIER_CIRCUITRY=AUTO";
	lpm_mux   mux1
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.data(table_bus_full_w),
	.result(wire_mux1_result),
	.sel(data_man_bus_w[22:18]));
	defparam
		mux1.lpm_pipeline = 1,
		mux1.lpm_size = 32,
		mux1.lpm_width = 16,
		mux1.lpm_widths = 5,
		mux1.lpm_type = "lpm_mux";
	assign
		aclr = 1'b0,
		and_b0_w = ({30{slope_w[5]}} & shift_b0_w),
		and_b1_w = ({30{slope_w[4]}} & shift_b1_w),
		and_b2_w = ({30{slope_w[3]}} & shift_b2_w),
		and_b3_w = ({30{slope_w[2]}} & shift_b3_w),
		and_b4_w = ({30{slope_w[1]}} & shift_b4_w),
		and_b5_w = ({30{slope_w[0]}} & shift_b5_w),
		approx_c_w = 7'b1100000,
		approx_mx_w = {gnd_w, vcc_w, man_dffe_0[22:18]},
		approx_y_w = {wire_approx_sub_result[5:0], {7{gnd_w}}},
		c_offset_w = {{3{gnd_w}}, intercept_dffe},
		clk_en = 1'b1,
		const_2_w = 26'b10000000000000000000000000,
		const_bias_adj_greater_one_w = 9'b011111101,
		const_bias_adj_one_w = 9'b011111110,
		const_bias_adj_w = (({9{(~ man_zero_w)}} & const_bias_adj_greater_one_w) | ({9{man_zero_w}} & const_bias_adj_one_w)),
		data_exp_bus_w = data[30:23],
		data_man_bus_w = data[22:0],
		data_sign_w = data[31],
		division_by_zero_w = zero_input_w,
		exp_and_msb_w = wire_altfp_inv_and_or5_result,
		exp_bus_w = exp_dffe1_11,
		exp_exc_ones_w = {8{1'b1}},
		exp_exc_zeros_w = {8{1'b0}},
		exp_one_w = exp_and_msb_w,
		exp_or_msb_w = wire_altfp_inv_and_or4_result,
		exp_res_w = exp_dffe2_2,
		exp_zero_w = (~ exp_or_msb_w),
		gnd_w = 1'b0,
		infi_res_w = {sign_exc_bit_w, exp_exc_ones_w, man_exc_zeros_w},
		infinite_input_w = infinite_input_dffe,
		infinite_out_w = infinite_dffe[2],
		infinite_w = zero_input_w,
		man_and_msb_w = wire_altfp_inv_and_or3_result,
		man_bus_w = man_dffe_11,
		man_exc_nan_w = {vcc_w, man_exc_zeros_w[21:0]},
		man_exc_zeros_w = {23{1'b0}},
		man_non_zero_w = man_or_msb_w,
		man_one_w = man_and_msb_w,
		man_or_msb_w = wire_altfp_inv_and_or2_result,
		man_out_0_w = {vcc_w, man_dffe_4[22:0]},
		man_out_1_w = {vcc_w, man_dffe_11[22:0]},
		man_res_w = x_2_w[22:0],
		man_zero_w = (~ man_or_msb_w),
		modified_c_w = wire_modified_add_result[12:0],
		mux_1_res_w = (({32{infinite_out_w}} & infi_res_w) | ({32{(~ infinite_out_w)}} & norm_res_int_w)),
		mux_2_res_w = (({32{zero_out_w}} & zero_res_w) | ({32{(~ zero_out_w)}} & mux_1_res_w)),
		mux_3_res_w = (({32{nan_out_w}} & nan_res_w) | ({32{(~ nan_out_w)}} & mux_2_res_w)),
		nan_input_w = nan_input_dffe,
		nan_out_w = nan_dffe[2],
		nan_res_w = {sign_exc_bit_w, exp_exc_ones_w, man_exc_nan_w},
		nan_w = nan_input_w,
		norm_res_int_w = {sign_res_w, exp_res_w, man_res_w},
		result = result_output_dffe,
		shift_b0_w = {gnd_w, vcc_w, man_dffe_0, {5{gnd_w}}},
		shift_b1_w = {{2{gnd_w}}, vcc_w, man_dffe_0, {4{gnd_w}}},
		shift_b2_w = {{3{gnd_w}}, vcc_w, man_dffe_0, {3{gnd_w}}},
		shift_b3_w = {{4{gnd_w}}, vcc_w, man_dffe_0, {2{gnd_w}}},
		shift_b4_w = {{5{gnd_w}}, vcc_w, man_dffe_0, gnd_w},
		shift_b5_w = {{6{gnd_w}}, vcc_w, man_dffe_0},
		sign_exc_bit_w = sign_res_w,
		sign_res_w = sign_dffe[18],
		slope_w = wire_mux1_result[15:10],
		table_bus_full_w = {16'b0100010000000001, 16'b0100010010000001, 16'b0100100010000111, 16'b0100100100000111, 16'b0100110100010000, 16'b0101000100011100, 16'b0101000110011100, 16'b0101010110101011, 16'b0101100110111100, 16'b0101110111010000, 16'b0101111001010001, 16'b0110001001100111, 16'b0110011001111111, 16'b0110101010011010, 16'b0110111010110111, 16'b0111001011010101, 16'b0111101010010111, 16'b0111111010111010, 16'b1000001011011111, 16'b1000101010101101, 16'b1000111011010101, 16'b1001011010101011, 16'b1001111010000101, 16'b1010001010110011, 16'b1010111001000101, 16'b1011011000101010, 16'b1011111000010011, 16'b1100100110110111, 16'b1101010101100001, 16'b1110000100010001, 16'b1110110011000110, 16'b1111110001000000},
		underflow_w = (((~ infinite_input_w) & (~ nan_input_w)) & wire_cmpr6_ageb),
		vcc_w = 1'b1,
		x_0_w = x_initial_w,
		x_1_w = wire_outer_mult0_result[36:12],
		x_2_w = wire_outer_mult1_result[48:24],
		x_initial_w = wire_slope_r3c1_add_result,
		zero_input_w = zero_input_dffe,
		zero_out_w = zero_dffe[2],
		zero_res_w = {sign_exc_bit_w, exp_exc_zeros_w, man_exc_zeros_w},
		zero_w = ((~ nan_input_w) & (infinite_input_w | underflow_w));
endmodule //inverse_altfp_inv_vec
//VALID FILE


// synopsys translate_off
`timescale 1 ps / 1 ps
// synopsys translate_on
module inverse (
	clock,
	data,
	result);

	input	  clock;
	input	[31:0]  data;
	output	[31:0]  result;

	wire [31:0] sub_wire0;
	wire [31:0] result = sub_wire0[31:0];

	inverse_altfp_inv_vec	inverse_altfp_inv_vec_component (
				.clock (clock),
				.data (data),
				.result (sub_wire0));

endmodule

// ============================================================
// CNX file retrieval info
// ============================================================
// Retrieval info: LIBRARY: altera_mf altera_mf.altera_mf_components.all
// Retrieval info: PRIVATE: INTENDED_DEVICE_FAMILY STRING "Cyclone V"
// Retrieval info: CONSTANT: INTENDED_DEVICE_FAMILY STRING "UNUSED"
// Retrieval info: CONSTANT: LPM_HINT STRING "UNUSED"
// Retrieval info: CONSTANT: LPM_TYPE STRING "altfp_inv"
// Retrieval info: CONSTANT: PIPELINE NUMERIC "20"
// Retrieval info: CONSTANT: ROUNDING STRING "TO_NEAREST"
// Retrieval info: CONSTANT: WIDTH_EXP NUMERIC "8"
// Retrieval info: CONSTANT: WIDTH_MAN NUMERIC "23"
// Retrieval info: USED_PORT: clock 0 0 0 0 INPUT NODEFVAL "clock"
// Retrieval info: CONNECT: @clock 0 0 0 0 clock 0 0 0 0
// Retrieval info: USED_PORT: data 0 0 32 0 INPUT NODEFVAL "data[31..0]"
// Retrieval info: CONNECT: @data 0 0 32 0 data 0 0 32 0
// Retrieval info: USED_PORT: result 0 0 32 0 OUTPUT NODEFVAL "result[31..0]"
// Retrieval info: CONNECT: result 0 0 32 0 @result 0 0 32 0
// Retrieval info: GEN_FILE: TYPE_NORMAL inverse.v TRUE FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL inverse.qip TRUE FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL inverse.bsf TRUE TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL inverse_inst.v TRUE TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL inverse_bb.v TRUE TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL inverse.inc TRUE TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL inverse.cmp TRUE TRUE
// Retrieval info: LIB_FILE: lpm
